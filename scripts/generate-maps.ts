import { writeFile } from "node:fs/promises";
import { type Unpacked, pack } from "../src/lib/deltapacking.ts";
import entitiesRaw from "./entities.json" with { type: "json" };

const assumption = /^&[A-Za-z][A-Za-z0-9]{1,30};?$/;
// Generate a hierarchy where each level is a character code
const hierarchy: Record<string, Record<string, string[]>> = {};
for (const [entity, { codepoints, characters }] of Object.entries(
  entitiesRaw,
)) {
  // Verify assumption
  if (!assumption.test(entity))
    throw new Error(`Entity ${entity} does not match assumption 1`);
  if (!entity.endsWith(";")) {
    const hasWithSemi = entity + ";" in entitiesRaw;
    if (!hasWithSemi)
      throw new Error(`Entity ${entity} does not match assumption 2`);
  }
  if (codepoints.length < 1 || codepoints.length > 2)
    throw new Error(`Entity ${entity} does not match assumption 3`);
  if (characters.length < 1 || characters.length > 2)
    throw new Error(`Entity ${entity} does not match assumption 4`);
  if (
    codepoints.length > 1 &&
    /^[^A-Za-z0-9 ]{2}$/gu.test(characters) &&
    !/^[^A-Za-z0-9 ]\p{M}?$/u.test(characters) &&
    !/^\u205f\u200a$/.test(characters)
  )
    throw new Error(`Entity ${entity} does not match assumption 5`);

  const firstLevel = characters.charCodeAt(0);
  const secondLevel =
    characters.length == 1 ? "0" : characters.charCodeAt(1).toString();
  hierarchy[firstLevel] ||= {};
  hierarchy[firstLevel][secondLevel] ||= [];
  hierarchy[firstLevel][secondLevel].push(entity);
}

const iterateMapping = <T>(mapping: Record<string, T>) =>
  Object.entries(mapping).map(([k, v]) => [+k, v] as const);

// Generate mapping
const firstLevel: Unpacked = [];
for (const [code, entities] of iterateMapping(hierarchy)) {
  const secondLevel: Unpacked = [];

  for (const [subcode, entityOptions] of iterateMapping(entities)) {
    const excludedOptions = new Set();
    for (const entity of entityOptions) {
      if (excludedOptions.has(entity)) continue;

      let value: string;
      if (!entity.endsWith(";")) {
        value = `${entity.slice(1)}!`;
        excludedOptions.add(`${entity};`);
      } else {
        value = entity.slice(1, -1);
      }

      secondLevel.push({ index: subcode, value });
    }
  }

  if (!secondLevel.length) continue;

  // Separate each second level entry (instance of entity) with the character ">"
  firstLevel.push({
    index: code,
    value: pack(secondLevel, ">"),
  });
}

// Separate each first level entry (character that starts entities) with a linebreak
const output = pack(firstLevel, "\n", ">");

// Generate code
await writeFile(
  "src/resources/map.ts",
  `// Generated by scripts/generate-maps.ts
import { unpack } from "../lib/deltapacking.ts";
const packed = \`${output}\`;
export const encodeMap = /*#__PURE__*/ (() => {
  const map: Record<string, string> = {};
  unpack(packed, "\\n", ({ index: firstLevel, value }) => {
    unpack(value, ">", ({ index: secondLevel, value: entity }) => {
      if (entity.endsWith("!")) entity = entity.slice(0, -1);
      entity = \`&\${entity};\`;
      const character = secondLevel ? String.fromCharCode(firstLevel, secondLevel) : String.fromCharCode(firstLevel);
      const existingEntity = map[character];
      if (existingEntity) {
        if (entity.length > existingEntity.length) return;
        if (entity.length == existingEntity.length && entity.toLowerCase() != entity) return;
      }
      map[character] = entity;
    });
  });
  return map;
})();
export const decodeMap = /*#__PURE__*/ (() => {
  const map: Record<string, string> = {};
  unpack(packed, "\\n", ({ index: firstLevel, value }) => {
    unpack(value, ">", ({ index: secondLevel, value: entity }) => {
      const character = secondLevel ? String.fromCharCode(firstLevel, secondLevel) : String.fromCharCode(firstLevel);
      if (entity.endsWith("!")) {
        map[\`\${entity.slice(0, -1)}\`] = character;
        map[\`\${entity.slice(0, -1)};\`] = character;
      } else {
        map[\`\${entity};\`] = character;
      }
    });
  });
  return map;
})();
`,
);
