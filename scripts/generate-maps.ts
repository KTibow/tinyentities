import { writeFile } from "node:fs/promises";
import { type Unpacked, pack } from "../src/lib/deltapacking.ts";
import entitiesRaw from "./entities.json" with { type: "json" };

const assumption = /^&[A-Za-z][A-Za-z0-9]+;?$/;
// Generate a hierarchy where each level is a character code
const hierarchy: Record<string, Record<string, string[]>> = {};
for (const [entity, { characters }] of Object.entries(entitiesRaw)) {
  // Verify assumption
  if (!assumption.test(entity))
    throw new Error(`Entity ${entity} does not match assumption`);

  const firstLevel = characters.charCodeAt(0);
  const secondLevel =
    characters.length == 1 ? "0" : characters.charCodeAt(1).toString();
  hierarchy[firstLevel] ||= {};
  hierarchy[firstLevel][secondLevel] ||= [];
  hierarchy[firstLevel][secondLevel].push(entity);
}

const iterateMapping = <T>(mapping: Record<string, T>) =>
  Object.entries(mapping).map(([k, v]) => [+k, v] as const);

// Generate mapping
const firstLevel: Unpacked = [];
for (const [code, entities] of iterateMapping(hierarchy)) {
  const secondLevel: Unpacked = [];

  for (const [subcode, entityOptions] of iterateMapping(entities)) {
    for (const entity of entityOptions) {
      secondLevel.push({ index: subcode, value: entity });
    }
  }

  if (!secondLevel.length) continue;

  // Separate each second level entry (instance of entity) with the character ">"
  firstLevel.push({
    index: code,
    value: pack(secondLevel, ">", { isEntity: true }),
  });
}

// Separate each first level entry (character that starts entities) with a linebreak
const output = pack(firstLevel, "\n", { subseparator: ">" });

// Generate code
await writeFile(
  "src/resources/map.ts",
  `// Generated by scripts/generate-maps.ts
import { unpack } from "../lib/deltapacking.ts";
export const hierarchy: Map<number, Map<number, string[]>> = new Map();
for (const { index: firstLevel, value } of unpack(\`${output}\`, "\\n")) {
  const firstLevelNum = Number(firstLevel);
  if (!hierarchy.has(firstLevelNum)) {
    hierarchy.set(firstLevelNum, new Map());
  }
  const secondLevelMap = hierarchy.get(firstLevelNum)!;
  for (const { index: secondLevel, value: entity } of unpack(value, ">")) {
    const secondLevelNum = Number(secondLevel);
    if (!secondLevelMap.has(secondLevelNum)) {
      secondLevelMap.set(secondLevelNum, []);
    }
    secondLevelMap.get(secondLevelNum)!.push(entity);
  }
}
`,
);
