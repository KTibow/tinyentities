import { writeFile } from "node:fs/promises";
import { type Unpacked, pack } from "../src/lib/deltapacking.ts";
import entitiesRaw from "./entities.json" with { type: "json" };

const assumption = /^&[A-Za-z][A-Za-z0-9]+;?$/;
// Generate a hierarchy where each level is a character code
const hierarchy: Record<string, Record<string, string[]>> = {};
for (const [entity, { codepoints, characters }] of Object.entries(
  entitiesRaw,
)) {
  // Verify assumption
  if (!assumption.test(entity))
    throw new Error(`Entity ${entity} does not match assumption 1`);
  if (!entity.endsWith(";")) {
    const hasWithSemi = entity + ";" in entitiesRaw;
    if (!hasWithSemi)
      throw new Error(`Entity ${entity} does not match assumption 2`);
  }
  if (codepoints.length < 1 || codepoints.length > 2)
    throw new Error(`Entity ${entity} does not match assumption 3`);
  if (characters.length < 1 || characters.length > 2)
    throw new Error(`Entity ${entity} does not match assumption 4`);
  if (
    codepoints.length > 1 &&
    /^[^A-Za-z0-9 ]{2}$/gu.test(characters) &&
    !/^[^A-Za-z0-9 ]\p{M}?$/u.test(characters) &&
    !/^\u205f\u200a$/.test(characters)
  )
    throw new Error(`Entity ${entity} does not match assumption 5`);

  const firstLevel = characters.charCodeAt(0);
  const secondLevel =
    characters.length == 1 ? "0" : characters.charCodeAt(1).toString();
  hierarchy[firstLevel] ||= {};
  hierarchy[firstLevel][secondLevel] ||= [];
  hierarchy[firstLevel][secondLevel].push(entity);
}

const iterateMapping = <T>(mapping: Record<string, T>) =>
  Object.entries(mapping).map(([k, v]) => [+k, v] as const);

// Generate mapping
const firstLevel: Unpacked = [];
for (const [code, entities] of iterateMapping(hierarchy)) {
  const secondLevel: Unpacked = [];

  for (const [subcode, entityOptions] of iterateMapping(entities)) {
    for (const entity of entityOptions) {
      secondLevel.push({ index: subcode, value: entity });
    }
  }

  if (!secondLevel.length) continue;

  // Separate each second level entry (instance of entity) with the character ">"
  firstLevel.push({
    index: code,
    value: pack(secondLevel, ">", { isEntity: true }),
  });
}

// Separate each first level entry (character that starts entities) with a linebreak
const output = pack(firstLevel, "\n", { subseparator: ">" });

// Generate code
await writeFile(
  "src/resources/map.ts",
  `// Generated by scripts/generate-maps.ts
import { unpack } from "../lib/deltapacking.ts";
export const hierarchy = /*#__PURE__*/ (() => {
  const hierarchy: Map<number, Map<number, string[]>> = new Map();
  for (const { index: firstLevel, value } of unpack(\`${output}\`, "\\n")) {
    const firstLevelNum = Number(firstLevel);
    if (!hierarchy.has(firstLevelNum)) {
      hierarchy.set(firstLevelNum, new Map());
    }
    const secondLevelMap = hierarchy.get(firstLevelNum)!;
    for (const { index: secondLevel, value: entity } of unpack(value, ">", true)) {
      const secondLevelNum = Number(secondLevel);
      if (!secondLevelMap.has(secondLevelNum)) {
        secondLevelMap.set(secondLevelNum, []);
      }
      secondLevelMap.get(secondLevelNum)!.push(entity);
    }
  }
  return hierarchy;
})();
`,
);
